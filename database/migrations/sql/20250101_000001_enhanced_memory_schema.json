{
  "version": "20250101_000001",
  "name": "Enhanced Memory Schema",
  "description": "Add vector embeddings, improved indexing, and memory versioning for reliable memory system",
  "up_sql": "-- Enhanced Memory Schema Migration\n\n-- Add vector embeddings support\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- Add embedding column to user_memories\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS embedding vector(1536);\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS embedding_model TEXT DEFAULT 'text-embedding-ada-002';\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true;\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS duplicate_of UUID REFERENCES user_memories(id);\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS confidence_score FLOAT DEFAULT 1.0;\nALTER TABLE user_memories ADD COLUMN IF NOT EXISTS source_conversation_id UUID REFERENCES conversations(id);\n\n-- Enhanced indexing for memory queries\nCREATE INDEX IF NOT EXISTS idx_memories_embedding ON user_memories USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);\nCREATE INDEX IF NOT EXISTS idx_memories_active ON user_memories(user_id, is_active) WHERE is_active = true;\nCREATE INDEX IF NOT EXISTS idx_memories_importance ON user_memories(user_id, importance_score DESC) WHERE is_active = true;\nCREATE INDEX IF NOT EXISTS idx_memories_updated ON user_memories(user_id, updated_at DESC) WHERE is_active = true;\nCREATE INDEX IF NOT EXISTS idx_memories_type_category ON user_memories(user_id, memory_type, category) WHERE is_active = true;\nCREATE INDEX IF NOT EXISTS idx_memories_name_search ON user_memories USING gin(to_tsvector('english', name)) WHERE is_active = true;\nCREATE INDEX IF NOT EXISTS idx_memories_fact_search ON user_memories USING gin(to_tsvector('english', fact)) WHERE is_active = true;\n\n-- Memory deduplication and cleanup functions\nCREATE OR REPLACE FUNCTION find_duplicate_memories(p_user_id UUID, p_fact TEXT, p_similarity_threshold FLOAT DEFAULT 0.95)\nRETURNS TABLE(memory_id UUID, similarity_score FLOAT) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT \n    id,\n    similarity(fact, p_fact) as sim_score\n  FROM user_memories \n  WHERE user_id = p_user_id \n    AND is_active = true\n    AND similarity(fact, p_fact) > p_similarity_threshold\n  ORDER BY sim_score DESC;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to mark memory as duplicate\nCREATE OR REPLACE FUNCTION mark_memory_duplicate(p_memory_id UUID, p_duplicate_of UUID)\nRETURNS BOOLEAN AS $$\nBEGIN\n  UPDATE user_memories \n  SET is_active = false, \n      duplicate_of = p_duplicate_of,\n      updated_at = NOW()\n  WHERE id = p_memory_id;\n  \n  RETURN FOUND;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to clean old inactive memories\nCREATE OR REPLACE FUNCTION cleanup_old_memories(p_days_old INTEGER DEFAULT 90)\nRETURNS INTEGER AS $$\nDECLARE\n  deleted_count INTEGER;\nBEGIN\n  DELETE FROM user_memories \n  WHERE is_active = false \n    AND updated_at < NOW() - INTERVAL '%s days' % p_days_old;\n  \n  GET DIAGNOSTICS deleted_count = ROW_COUNT;\n  RETURN deleted_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Memory backup table for point-in-time recovery\nCREATE TABLE IF NOT EXISTS user_memories_backup (\n  backup_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  backup_date TIMESTAMPTZ DEFAULT NOW(),\n  user_id UUID NOT NULL,\n  memory_data JSONB NOT NULL,\n  backup_type TEXT DEFAULT 'daily' CHECK (backup_type IN ('daily', 'manual', 'pre_migration'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_memory_backup_user_date ON user_memories_backup(user_id, backup_date DESC);\nCREATE INDEX IF NOT EXISTS idx_memory_backup_type ON user_memories_backup(backup_type, backup_date DESC);\n\n-- Function to create memory backup\nCREATE OR REPLACE FUNCTION backup_user_memories(p_user_id UUID, p_backup_type TEXT DEFAULT 'manual')\nRETURNS UUID AS $$\nDECLARE\n  backup_id UUID;\nBEGIN\n  INSERT INTO user_memories_backup (user_id, memory_data, backup_type)\n  SELECT \n    p_user_id,\n    jsonb_agg(to_jsonb(um.*)) as memory_data,\n    p_backup_type\n  FROM user_memories um\n  WHERE um.user_id = p_user_id\n  RETURNING backup_id INTO backup_id;\n  \n  RETURN backup_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Memory statistics view\nCREATE OR REPLACE VIEW memory_stats AS\nSELECT \n  user_id,\n  COUNT(*) as total_memories,\n  COUNT(*) FILTER (WHERE is_active = true) as active_memories,\n  COUNT(*) FILTER (WHERE is_active = false) as inactive_memories,\n  AVG(importance_score) as avg_importance,\n  MAX(updated_at) as last_updated,\n  COUNT(DISTINCT memory_type) as memory_types_count,\n  COUNT(DISTINCT category) as categories_count\nFROM user_memories\nGROUP BY user_id;",
  "down_sql": "-- Rollback Enhanced Memory Schema\n\n-- Drop views\nDROP VIEW IF EXISTS memory_stats;\n\n-- Drop functions\nDROP FUNCTION IF EXISTS backup_user_memories(UUID, TEXT);\nDROP FUNCTION IF EXISTS cleanup_old_memories(INTEGER);\nDROP FUNCTION IF EXISTS mark_memory_duplicate(UUID, UUID);\nDROP FUNCTION IF EXISTS find_duplicate_memories(UUID, TEXT, FLOAT);\n\n-- Drop backup table\nDROP TABLE IF EXISTS user_memories_backup;\n\n-- Drop indexes\nDROP INDEX IF EXISTS idx_memories_fact_search;\nDROP INDEX IF EXISTS idx_memories_name_search;\nDROP INDEX IF EXISTS idx_memories_type_category;\nDROP INDEX IF EXISTS idx_memories_updated;\nDROP INDEX IF EXISTS idx_memories_importance;\nDROP INDEX IF EXISTS idx_memories_active;\nDROP INDEX IF EXISTS idx_memories_embedding;\n\n-- Remove columns\nALTER TABLE user_memories DROP COLUMN IF EXISTS source_conversation_id;\nALTER TABLE user_memories DROP COLUMN IF EXISTS confidence_score;\nALTER TABLE user_memories DROP COLUMN IF EXISTS duplicate_of;\nALTER TABLE user_memories DROP COLUMN IF EXISTS is_active;\nALTER TABLE user_memories DROP COLUMN IF EXISTS version;\nALTER TABLE user_memories DROP COLUMN IF EXISTS embedding_model;\nALTER TABLE user_memories DROP COLUMN IF EXISTS embedding;",
  "created_at": "2025-01-01T00:00:01.000000"
}